local StateMachine = require "main/scripts/state_machine"

-- Player manager
local PlayerManager = require "main/scripts/managers/player_info_manager"

-- Jugadores
local BountyHunter = require "main/scripts/player/bounty_hunter"
local Robot = require "main/scripts/player/robot"
-- Armas
local BountyHunterWeapon = require "main/scripts/weapons/bounty_hunter_weapon"
local RobotWeapon = require "main/scripts/weapons/robot_weapon"

-- Variables globales
local bounds = {x_min = 10, x_max = 460, y_min = 10, y_max = 620} -- Límites de la pantalla


-- Constantes para los inputs
local input_left = hash("left")
local input_right = hash("right")
local input_up = hash("up")
local input_down = hash("down")
local input_shoot = hash("shoot")


function init(self)
    -- Registra la URL del jugador en el módulo
    PlayerManager.set_player(msg.url())

    self.current_level = 1
    self.current_level_base = nil

    self.powerup_timer = 0
    self.active_powerup = nil
    self.real_value = 0 -- valor antes del powerup 

    msg.post("#bounty_hunter_sprite", "disable")
    msg.post("#robot_sprite", "disable")
    -- Adquirir el foco de entrada
    msg.post(".", "acquire_input_focus")
    -- Crear una instancia de Robot
    -- Selección del personaje (puede venir de un archivo de configuración o input del jugador)
    local selected_character = "bounty_hunter" -- O "bounty_hunter"

    if selected_character == "bounty_hunter" then
        self.player = BountyHunter:new()
        self.sprite = "#bounty_hunter_sprite" -- Cambia el sprite
        self.weapon = BountyHunterWeapon:new(msg.url("/factories#bounty_hunter_bullet_factory"))
    elseif selected_character == "robot" then
        self.player = Robot:new()
        self.sprite = "#robot_sprite" -- Cambia el sprite
        self.weapon = RobotWeapon:new(msg.url("/factories#robot_bullet_factory"))
    end
    msg.post(self.sprite, "enable")
    --print("Jugador creado: " .. self.player.name)
    -- Inicializar la máquina de estados
    ini_state_machine(self)
    -- Configuración inicial del jugador
    self.position = go.get_position()
    self.inputs = {} -- Tabla para rastrear inputs
    --print("ID del jugador: ", go.get_id("/bounty_hunter_bullet_factory"))

end

function on_message(self, message_id, message, sender)
    if message_id == hash("current_level") then
        -- El nivel actual se encuentra en message.level
        --print("Nivel actual recibido: zzzzzzzzzzzzzzzz", message.level)
        -- Puedes guardar el nivel o realizar alguna acción específica
        self.current_level = message.level
        self.current_level_base = message.base
        --print("Nivel cargado:", self.current_level_base)
        --msg.post("@broadcast", "current_level", { level = self.current_level, base = self.current_level_base })
    end
    if message_id == hash("weapon_speed") then
        -- Checar si este powerup está activo
        if self.active_powerup == "weapon_speed" then
            -- revertir efecto
            self.weapon.fire_rate = self.real_value
        end
        -- Cambiar la velocidad de disparo
        print("Cambiando velocidad de disparo")
        self.active_powerup = "weapon_speed"
        self.real_value = self.weapon.fire_rate
        self.weapon.fire_rate =  self.weapon.fire_rate * message.effect
        self.powerup_timer = message.duration
        print("Nueva velocidad de disparo:", self.weapon.fire_rate)
    end
end

function update(self, dt)
    -- Actualizar temporizador del disparo
    self.weapon:update(dt) -- Actualiza el temporizador del arma
     -- Aquí puedes actualizar la lógica del jugador
     --self.player.fire_timer = self.player.fire_timer - dt
    -- Actualizar la máquina de estados
    self.state_machine:update(dt)

    -- Powerups
    if self.powerup_timer > 0 then
        self.powerup_timer = self.powerup_timer - dt
        if self.powerup_timer <= 0 then
            -- revertir efecto
            if self.active_powerup == "weapon_speed" then
                self.weapon.fire_rate = self.real_value
            end
            self.active_powerup = nil
        end
    end
end

function ini_state_machine(self)
    -- Inicializar la máquina de estados
    self.state_machine = StateMachine.new()

    -- Estado IDLE
    self.state_machine:add_state("idle", {
        enter = function()
            print("Entrando al estado IDLE")
            sprite.play_flipbook(msg.url(self.sprite), "idle")
        end,
        update = function(dt)
            if has_movement_input(self) then
                self.state_machine:set_state("moving")
            elseif self.inputs[input_shoot] then
                self.state_machine:set_state("shooting")
            end
        end,
        exit = function()
            print("Saliendo del estado IDLE")
        end
    })

    -- Estado MOVING
    self.state_machine:add_state("moving", {
        enter = function()
            print("Entrando al estado MOVING")
        end,
        update = function(dt)
            handle_movement(self, dt)
            if not has_movement_input(self) then
                self.state_machine:set_state("idle")
            elseif self.inputs[input_shoot] then
                self.state_machine:set_state("shooting")
            end
        end,
        exit = function()
            print("Saliendo del estado MOVING")
            sprite.play_flipbook(msg.url(self.sprite), "idle")
        end
    })

    -- Estado SHOOTING
    self.state_machine:add_state("shooting", {
        enter = function()
            print("Entrando al estado SHOOTING")
        end,
        update = function(dt)
            handle_movement(self, dt) -- Permite movimiento mientras dispara
            self.weapon:fire(self.position, vmath.vector3(0, 1, 0)) -- Disparo hacia arriba
            if not self.inputs[input_shoot] then
                if has_movement_input(self) then
                    self.state_machine:set_state("moving")
                else
                    self.state_machine:set_state("idle")
                end
            end
        end,
        exit = function()
            print("Saliendo del estado SHOOTING")
        end
    })

    -- Estado inicial
    self.state_machine:set_state("idle")
end

function handle_movement(self, dt)
    local move = vmath.vector3(0, 0, 0)
    if self.inputs[input_up] then
        move.y = move.y + 1
        sprite.play_flipbook(msg.url(self.sprite), "idle")
    end
    if self.inputs[input_down] then
        move.y = move.y - 1
        sprite.play_flipbook(msg.url(self.sprite), "idle")
    end
    if self.inputs[input_left] then
        move.x = move.x - 1
        sprite.play_flipbook(msg.url(self.sprite), "left")
    end
    if self.inputs[input_right] then
        move.x = move.x + 1
        sprite.play_flipbook(msg.url(self.sprite), "right")
    end

    if move.x == 0 and move.y == 0 then
        sprite.play_flipbook(msg.url(self.sprite), "idle")
    end
    

    -- Solo normalizar si el vector no es cero
    if move.x ~= 0 or move.y ~= 0 then
        move = vmath.normalize(move) * self.player.speed * dt
        self.position = self.position + move
    end

    -- Restringir al jugador dentro de los límites de la pantalla
    self.position.x = math.max(bounds.x_min, math.min(bounds.x_max, self.position.x))
    self.position.y = math.max(bounds.y_min, math.min(bounds.y_max, self.position.y))
    go.set_position(self.position)
end

function handle_shooting(self, dt)
    self.player.fire_timer = self.player.fire_timer - dt
    if self.inputs[input_shoot] and self.player.fire_timer <= 0 then
        self.player.fire_timer = self.player.fire_rate
        --factory.create("#bullet_factory", self.position + vmath.vector3(0, 10, 0))
    end
end

function has_movement_input(self)
    return self.inputs[input_up] or self.inputs[input_down] or self.inputs[input_left] or self.inputs[input_right]
end

function on_input(self, action_id, action)
    if action.pressed then
        self.inputs[action_id] = true
    elseif action.released then
        self.inputs[action_id] = false
    end
end
