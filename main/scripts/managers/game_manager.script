-- game_manager.script
local formations_data  = require "main/scripts/formations"
local dispatcher = require "main/scripts/dispatcher"
local score = 0 -- Variable de puntaje
local lives = 0
local health = 0

local current_level = 1
local LEVEL_DATA = {
    { enemy_count = 5, proxy = "/level1#proxy" },
    { enemy_count = 10, proxy = "/level2#proxy" },
    { enemy_count = 15, proxy = "/level3#proxy" }
}


-- speed of the time in the collection proxy
go.property("speed", 1)

function init(self)
    self.current_level_proxy = nil -- Declaramos explícitamente esta variable
    self.loading = false -- Para evitar cargar niveles mientras otro se está cargando
    load_level(self, current_level)
    --load_level_formations(self, self.current_level)
    --msg.post("@broadcast", "current_level", { level = self.current_level })
    --msg.post("/level1/enemy_manager", "spawn_enemies", { level = self.current_level })
end

function update(self, dt)
    -- Aquí puedes manejar transiciones de nivel, puntajes, etc.
    -- update the time step of the proxy each frame since it might be animated
    msg.post(LEVEL_DATA[current_level].proxy, "set_time_step", { factor = self.speed, mode = 0 })
end

function on_message(self, message_id, message, sender)
    if message_id == hash("level_cleared") then
        
        --current_level = current_level + 1
        if current_level <= #LEVEL_DATA then
            self.loading = false
            load_level(self, current_level)
        else
            print("¡Juego completado!")
        end
    elseif message_id == hash("proxy_loaded") then
        -- Activar la colección del nivel cargado
        msg.post(sender, "init")
        msg.post(sender, "enable")
        self.loading = false
        -- Guardar la URL base del nivel cargado
        self.current_level_base = msg.url(sender)
        print("Nivel cargado:", self.current_level_base.socket)
        --dispatcher.broadcast(hash("current_level"), { level = self.current_level, base = self.current_level_base.socket })
       -- msg.post("@broadcast", "current_level", { level = self.current_level, base = self.current_level_base.socket })
        print("Nivel cargado y activado:", current_level)
        -- Comenzar countdown enviando mensaje 
        msg.post("/health_gui", "start_countdown", { time = 99 })
       
    elseif message_id == hash("proxy_unloaded") then
        -- Una vez descargado, cargar el nuevo nivel
        current_level = current_level + 1
        load_level(self, current_level)
    end

    if message_id == hash("set_health") then
        self.health = message.health
        msg.post("/health_gui", "set_health", { health = self.health, max_health = message.max_health })
    end

    if message_id == hash("set_lives") then
        lives = message.lives
        msg.post("/lives_gui", "set_lives", { lives = lives })
    end

    if message_id == hash("add_score") then
        score = score + message.points
         -- Enviar actualización a la GUI
         msg.post("/score_gui", "update_score", { points = score })
    elseif message_id == hash("get_score") then
        msg.post(sender, "score_value", { points = score }) -- Devolver puntaje
    end

    -- Detener Countdown
    if message_id == hash("stop_countdown") then
        msg.post("/health_gui", "stop_countdown")
    end

    if message_id == hash("player_died") then
        lives = lives - 1
        msg.post("/lives_gui", "update_lives", { lives = self.lives })

        if lives > 0 then
            msg.post(message.player_url, "respawn", { x = message.x, y = message.y })
        else
            -- Game Over
            --msg.post("main:/ui", "show_game_over")
             -- 1. Pausar todos los game objects
            go.cancel_animations("#", "speed")
            -- make sure speed never goes below 0
            self.speed = 0
        end
    end
end

function load_level_formations(self, level)
    self.spawn_formations = formations_data[level] or {} -- Carga las formaciones del nivel actual
end

function get_spawn_formations(self, level)
    return self.spawn_formations
end

function load_level(self, level)
    if self.loading then
        print("Ya se está cargando un nivel.")
        return
    end

    self.loading = true

    -- Descargar el nivel actual si existe
    if self.current_level_proxy then
        -- Esperar 5 segundos antes de descargar el nuevo nivel
        timer.delay(5.0, false, function()
            msg.post(self.current_level_proxy, "unload")
            self.loading = false
            self.current_level_proxy = nil
        end)
    else
        -- Si no hay nivel cargado, cargar directamente el nuevo nivel
        local proxy = LEVEL_DATA[level].proxy
        self.current_level_proxy = proxy
        msg.post(proxy, "load")
    end
end

function final(self)
    sys.save("game_data", { lives = lives, score = score }) -- Guardar el puntaje al salir
end