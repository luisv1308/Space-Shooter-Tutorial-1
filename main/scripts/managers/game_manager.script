-- game_manager.script
local formations_data  = require "main/scripts/formations"
local dispatcher = require "main/scripts/dispatcher"

local current_level = 1
local LEVEL_DATA = {
    { enemy_count = 5, proxy = "/level1#proxy" },
    { enemy_count = 10, proxy = "/level2#proxy" },
    { enemy_count = 15, proxy = "/level3#proxy" }
}

function init(self)
    self.current_level_proxy = nil -- Declaramos explícitamente esta variable
    self.loading = false -- Para evitar cargar niveles mientras otro se está cargando
    load_level(self, current_level)
    --load_level_formations(self, self.current_level)
    --msg.post("@broadcast", "current_level", { level = self.current_level })
    --msg.post("/level1/enemy_manager", "spawn_enemies", { level = self.current_level })
end

function update(self, dt)
    -- Aquí puedes manejar transiciones de nivel, puntajes, etc.
end

function on_message(self, message_id, message, sender)
    if message_id == hash("level_cleared") then
        
        --current_level = current_level + 1
        if current_level <= #LEVEL_DATA then
            self.loading = false
            load_level(self, current_level)
        else
            print("¡Juego completado!")
        end
    elseif message_id == hash("proxy_loaded") then
        -- Activar la colección del nivel cargado
        msg.post(sender, "init")
        msg.post(sender, "enable")
        self.loading = false
        -- Guardar la URL base del nivel cargado
        self.current_level_base = msg.url(sender)
        print("Nivel cargado:", self.current_level_base.socket)
        --dispatcher.broadcast(hash("current_level"), { level = self.current_level, base = self.current_level_base.socket })
       -- msg.post("@broadcast", "current_level", { level = self.current_level, base = self.current_level_base.socket })
        print("Nivel cargado y activado:", current_level)
       
    elseif message_id == hash("proxy_unloaded") then
        -- Una vez descargado, cargar el nuevo nivel
        current_level = current_level + 1
        load_level(self, current_level)
    end
end

function load_level_formations(self, level)
    self.spawn_formations = formations_data[level] or {} -- Carga las formaciones del nivel actual
end

function get_spawn_formations(self, level)
    return self.spawn_formations
end

function load_level(self, level)
    if self.loading then
        print("Ya se está cargando un nivel.")
        return
    end

    self.loading = true

    -- Descargar el nivel actual si existe
    if self.current_level_proxy then
        -- Esperar 5 segundos antes de descargar el nuevo nivel
        timer.delay(5.0, false, function()
            msg.post(self.current_level_proxy, "unload")
            self.loading = false
            self.current_level_proxy = nil
        end)
    else
        -- Si no hay nivel cargado, cargar directamente el nuevo nivel
        local proxy = LEVEL_DATA[level].proxy
        self.current_level_proxy = proxy
        msg.post(proxy, "load")
    end
end